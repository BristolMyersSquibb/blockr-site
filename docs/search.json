[
  {
    "objectID": "howto/01-export-code.html",
    "href": "howto/01-export-code.html",
    "title": "Export code",
    "section": "",
    "text": "Learn how to export code from blockr.\n\n\n\nPress the settings button:\n\n\n\nPress the “&lt;/&gt; Show Code” button:\n\n\n\nThat’s it! Idiomatic R code will appear in a pop-up modal. Copy and paste it where you like.",
    "crumbs": [
      "How-To",
      "Export code"
    ]
  },
  {
    "objectID": "howto/01-export-code.html#steps",
    "href": "howto/01-export-code.html#steps",
    "title": "Export code",
    "section": "",
    "text": "Press the settings button:\n\n\n\nPress the “&lt;/&gt; Show Code” button:\n\n\n\nThat’s it! Idiomatic R code will appear in a pop-up modal. Copy and paste it where you like.",
    "crumbs": [
      "How-To",
      "Export code"
    ]
  },
  {
    "objectID": "tutorials/02-build-a-dashboard.html",
    "href": "tutorials/02-build-a-dashboard.html",
    "title": "Build a dashboard",
    "section": "",
    "text": "In this tutorial you will learn how to transform a blockr workflow into a dashboard you can share with others.\n\n\n\n\n\n\nNote\n\n\n\nThis tutorial will use the data workflow created in the Build Your First App tutorial. Make sure to complete that tutorial first before proceeding with this one.\n\n\n\n\nYou can drag and drop windows to customize your workspace however you like. You can move them around, organize them into tabs, remove them, and resize them. Let’s see how each of these features work:\n\n\nTo move a window, grab the grey tab at the top and drag it wherever you like.\nLet’s start by dragging the plot block down underneath the dataset and filter blocks. As you drag a window, you’ll see a purple highlight showing where it will go when you drop it.\nLet’s move the plot block below the dataset and filter blocks to see how this works:\n\nOnce moved your app should now look like this:\n\nNext, let’s move the filter block to the left:\n\nYour app should now look like this:\n\n\n\n\nYou can also group windows into tab groups. To do this, simply drag a tab next to another tab to group them together.\nFor instance, let’s move the dataset block from the tab group on the right to the tab group on the left:\n\nYou should now see the dataset block is in the left tab group:\n\n\n\n\nSometimes you may wish to just remove a window all together. To do this, just click on the “x” next to the window name in the tab.\nFor instance, let’s remove the dataset window, as it might not be much use to see in our dashboard:\n\nIf you want to reverse this, you can also click the “+” button to add a window back into your app:\n\nBut for now, let’s leave the dataset block removed.\n\n\n\nAt this point your app should have the graph of blocks on the left, the filter block in the middle, and the plot block on the right. Each window should take up approximately the same width:\n\nTo create more space for our filter and plot blocks, let’s resize their windows. To do this, just drag the edge of the respective window to change its size:\n\n\n\n\n\n\nTo finish creating our dashboard, we’ll customize what users can see and interact with by controlling the visibility of different parts of our app.\n\n\nEach block has two components:\n\nInputs – the controls for a block\nOutputs – the return values (such as data or a plot)\n\nInside each block, you’ll see inputs and outputs separated by a faint grey line:\n\n\n\n\nYou can show or hide inputs and outputs using the “Input” and “Output” buttons located in the top-right corner of each block:\n\nBy default, all inputs and outputs are visible. To change this, simply click the input or output buttons to toggle the respective component on or off.\n\n\n\nLet’s toggle the output “off” for our filter block and the input “off” for our ggplot block:\n\nYou should now notice two things:\n\nThe output data table for the filter block and the input controls for the plot block are no longer visible\nThe input/output buttons change color to indicate whether their component is shown or hidden\n\nBy hiding the filter outputs and plot inputs, we’ve created a curated dashboard view where we control what users can see and interact with. In this case, users can now adjust the filter values and see the effects on the plot in real time, without being distracted by unnecessary components.\n\n\n\n\n\nIn this tutorial you learned how to transform your blockr workflow into a polished dashboard by customizing the layout and controlling what users see. You learned how to:\n\nMove windows by dragging tabs to rearrange your workspace layout\nGroup windows into tabs by dragging them next to each other\nRemove windows using the “x” button (and add them back with the “+” button)\nResize windows by dragging their edges to emphasize important components\nToggle inputs and outputs on and off using the buttons in the top-right corner of each block\n\nBy combining these techniques, you created a curated dashboard view that controls what users can interact with and see. You now have the skills to build custom dashboards tailored to your audience. Whether you’re creating an interactive report for stakeholders or a data exploration tool for colleagues, you can design layouts and control visibility to create exactly the experience your users need.",
    "crumbs": [
      "Tutorials",
      "Build a dashboard"
    ]
  },
  {
    "objectID": "tutorials/02-build-a-dashboard.html#rearrange-your-layout",
    "href": "tutorials/02-build-a-dashboard.html#rearrange-your-layout",
    "title": "Build a dashboard",
    "section": "",
    "text": "You can drag and drop windows to customize your workspace however you like. You can move them around, organize them into tabs, remove them, and resize them. Let’s see how each of these features work:\n\n\nTo move a window, grab the grey tab at the top and drag it wherever you like.\nLet’s start by dragging the plot block down underneath the dataset and filter blocks. As you drag a window, you’ll see a purple highlight showing where it will go when you drop it.\nLet’s move the plot block below the dataset and filter blocks to see how this works:\n\nOnce moved your app should now look like this:\n\nNext, let’s move the filter block to the left:\n\nYour app should now look like this:\n\n\n\n\nYou can also group windows into tab groups. To do this, simply drag a tab next to another tab to group them together.\nFor instance, let’s move the dataset block from the tab group on the right to the tab group on the left:\n\nYou should now see the dataset block is in the left tab group:\n\n\n\n\nSometimes you may wish to just remove a window all together. To do this, just click on the “x” next to the window name in the tab.\nFor instance, let’s remove the dataset window, as it might not be much use to see in our dashboard:\n\nIf you want to reverse this, you can also click the “+” button to add a window back into your app:\n\nBut for now, let’s leave the dataset block removed.\n\n\n\nAt this point your app should have the graph of blocks on the left, the filter block in the middle, and the plot block on the right. Each window should take up approximately the same width:\n\nTo create more space for our filter and plot blocks, let’s resize their windows. To do this, just drag the edge of the respective window to change its size:",
    "crumbs": [
      "Tutorials",
      "Build a dashboard"
    ]
  },
  {
    "objectID": "tutorials/02-build-a-dashboard.html#toggle-inputsoutputs-on-and-off",
    "href": "tutorials/02-build-a-dashboard.html#toggle-inputsoutputs-on-and-off",
    "title": "Build a dashboard",
    "section": "",
    "text": "To finish creating our dashboard, we’ll customize what users can see and interact with by controlling the visibility of different parts of our app.\n\n\nEach block has two components:\n\nInputs – the controls for a block\nOutputs – the return values (such as data or a plot)\n\nInside each block, you’ll see inputs and outputs separated by a faint grey line:\n\n\n\n\nYou can show or hide inputs and outputs using the “Input” and “Output” buttons located in the top-right corner of each block:\n\nBy default, all inputs and outputs are visible. To change this, simply click the input or output buttons to toggle the respective component on or off.\n\n\n\nLet’s toggle the output “off” for our filter block and the input “off” for our ggplot block:\n\nYou should now notice two things:\n\nThe output data table for the filter block and the input controls for the plot block are no longer visible\nThe input/output buttons change color to indicate whether their component is shown or hidden\n\nBy hiding the filter outputs and plot inputs, we’ve created a curated dashboard view where we control what users can see and interact with. In this case, users can now adjust the filter values and see the effects on the plot in real time, without being distracted by unnecessary components.",
    "crumbs": [
      "Tutorials",
      "Build a dashboard"
    ]
  },
  {
    "objectID": "tutorials/02-build-a-dashboard.html#summary",
    "href": "tutorials/02-build-a-dashboard.html#summary",
    "title": "Build a dashboard",
    "section": "",
    "text": "In this tutorial you learned how to transform your blockr workflow into a polished dashboard by customizing the layout and controlling what users see. You learned how to:\n\nMove windows by dragging tabs to rearrange your workspace layout\nGroup windows into tabs by dragging them next to each other\nRemove windows using the “x” button (and add them back with the “+” button)\nResize windows by dragging their edges to emphasize important components\nToggle inputs and outputs on and off using the buttons in the top-right corner of each block\n\nBy combining these techniques, you created a curated dashboard view that controls what users can interact with and see. You now have the skills to build custom dashboards tailored to your audience. Whether you’re creating an interactive report for stakeholders or a data exploration tool for colleagues, you can design layouts and control visibility to create exactly the experience your users need.",
    "crumbs": [
      "Tutorials",
      "Build a dashboard"
    ]
  },
  {
    "objectID": "tutorials/00-getting-started.html",
    "href": "tutorials/00-getting-started.html",
    "title": "blockr",
    "section": "",
    "text": "These documents are user-facing and not developer-facing. They will teach you how to use blockr, not how to develop it. If you are looking for developer docs, start here.\nThe documentation is split into four parts:\n\n\n\n\n\n\n\nLearn by doing with step-by-step tutorials that walk you through practical examples.\nTo the tutorials\n\n\n\n\n\n\n\n\n\n\nReach a specific goal with focused guides for common tasks.\nTo the how-to’s\n\n\n\n\n\n\n\n\n\n\nBroaden your understanding with in-depth explanations of key concepts.\nTo the fundamentals\n\n\n\n\n\n\n\n\n\n\nLookup a block with detailed specifications and parameters.\nTo the blocks",
    "crumbs": [
      "Tutorials",
      "Getting Started"
    ]
  },
  {
    "objectID": "tutorials/00-getting-started.html#getting-started",
    "href": "tutorials/00-getting-started.html#getting-started",
    "title": "blockr",
    "section": "",
    "text": "These documents are user-facing and not developer-facing. They will teach you how to use blockr, not how to develop it. If you are looking for developer docs, start here.\nThe documentation is split into four parts:\n\n\n\n\n\n\n\nLearn by doing with step-by-step tutorials that walk you through practical examples.\nTo the tutorials\n\n\n\n\n\n\n\n\n\n\nReach a specific goal with focused guides for common tasks.\nTo the how-to’s\n\n\n\n\n\n\n\n\n\n\nBroaden your understanding with in-depth explanations of key concepts.\nTo the fundamentals\n\n\n\n\n\n\n\n\n\n\nLookup a block with detailed specifications and parameters.\nTo the blocks",
    "crumbs": [
      "Tutorials",
      "Getting Started"
    ]
  },
  {
    "objectID": "blocks/02-visualisation.html",
    "href": "blocks/02-visualisation.html",
    "title": "blockr",
    "section": "",
    "text": "blockr.ggplot provides interactive blocks for data visualization using ggplot2. Each block offers a user interface for creating and customizing visualizations. Blocks can be connected together to create sophisticated data visualization pipelines.",
    "crumbs": [
      "Blocks",
      "blockr.ggplot"
    ]
  },
  {
    "objectID": "blocks/02-visualisation.html#blockr.ggplot",
    "href": "blocks/02-visualisation.html#blockr.ggplot",
    "title": "blockr",
    "section": "",
    "text": "blockr.ggplot provides interactive blocks for data visualization using ggplot2. Each block offers a user interface for creating and customizing visualizations. Blocks can be connected together to create sophisticated data visualization pipelines.",
    "crumbs": [
      "Blocks",
      "blockr.ggplot"
    ]
  },
  {
    "objectID": "blocks/02-visualisation.html#scatter-plot",
    "href": "blocks/02-visualisation.html#scatter-plot",
    "title": "blockr",
    "section": "Scatter Plot",
    "text": "Scatter Plot\nThe ggplot block creates visualizations using ggplot2. For scatter plots, use the “point” chart type to display relationships between two continuous variables.\nMap columns to the x and y axes to show how variables relate to each other. Add color and size aesthetics to encode additional variables. The color aesthetic uses categorical or continuous variables to assign colors to points, while size maps numeric values to point sizes. This is particularly effective for exploring correlations and patterns in multidimensional data.\nScatter plots support additional aesthetics including shape (for categorical distinctions) and alpha (transparency). Use alpha values between 0 and 1 to reduce overplotting in dense regions. The block automatically handles scale creation and legend generation for all mapped aesthetics.",
    "crumbs": [
      "Blocks",
      "blockr.ggplot"
    ]
  },
  {
    "objectID": "blocks/02-visualisation.html#bar-chart",
    "href": "blocks/02-visualisation.html#bar-chart",
    "title": "blockr",
    "section": "Bar Chart",
    "text": "Bar Chart\nBar charts display categorical data with rectangular bars. Use the “bar” chart type to compare values across categories or show frequency distributions.\nSelect a categorical variable for the x axis to create bars for each category. The fill aesthetic adds color coding by another categorical variable, automatically creating stacked or grouped bars. Choose between position adjustments: “stack” (default) stacks bars on top of each other, “dodge” places bars side-by-side, and “fill” creates proportional stacked bars showing percentages.\nBar charts work well for comparing discrete groups, showing distributions of categorical variables, or displaying summary statistics. The block handles count aggregation automatically when no y variable is specified.",
    "crumbs": [
      "Blocks",
      "blockr.ggplot"
    ]
  },
  {
    "objectID": "blocks/02-visualisation.html#line-chart",
    "href": "blocks/02-visualisation.html#line-chart",
    "title": "blockr",
    "section": "Line Chart",
    "text": "Line Chart\nLine charts connect data points to show trends over time or across ordered categories. Use the “line” chart type for time series or sequential data.\nMap a sequential variable (like time or age) to the x axis and a continuous variable to y. The color aesthetic creates separate lines for different groups, making it easy to compare trends across categories. Lines are automatically sorted by x values and grouped appropriately.\nLine charts support additional aesthetics including linetype for distinguishing groups with different line styles (solid, dashed, dotted) and size for varying line thickness. This visualization is ideal for temporal data, growth curves, and tracking changes over ordered sequences.",
    "crumbs": [
      "Blocks",
      "blockr.ggplot"
    ]
  },
  {
    "objectID": "blocks/02-visualisation.html#box-plot",
    "href": "blocks/02-visualisation.html#box-plot",
    "title": "blockr",
    "section": "Box Plot",
    "text": "Box Plot\nBox plots display the distribution of continuous data through quartiles. Use the “boxplot” chart type to compare distributions across groups or identify outliers.\nSelect a categorical variable for x and a continuous variable for y. The box shows the interquartile range (IQR) with a line at the median. Whiskers extend to the most extreme points within 1.5 × IQR from the box edges. Points beyond the whiskers are plotted individually as potential outliers. The fill aesthetic colors boxes by group.\nBox plots provide a compact summary of distribution shape, central tendency, and variability. They’re particularly effective when comparing multiple groups side-by-side, as the aligned boxes make differences in median, spread, and skewness immediately visible.",
    "crumbs": [
      "Blocks",
      "blockr.ggplot"
    ]
  },
  {
    "objectID": "blocks/02-visualisation.html#violin-plot",
    "href": "blocks/02-visualisation.html#violin-plot",
    "title": "blockr",
    "section": "Violin Plot",
    "text": "Violin Plot\nViolin plots combine box plots with density plots to show the full distribution shape. Use the “violin” chart type when distribution shape matters as much as summary statistics.\nLike box plots, violin plots require a categorical x variable and continuous y variable. The width of the violin at each y value represents the density (frequency) of data at that value. This reveals features like multimodality, skewness, and distribution tails that box plots obscure. The fill aesthetic colors violins by group for easy comparison.\nViolin plots are superior to box plots when you need to see whether distributions are unimodal or multimodal, identify subtle differences in distribution shape, or understand the full data density rather than just quartiles. They’re especially valuable with larger datasets where distribution details matter.",
    "crumbs": [
      "Blocks",
      "blockr.ggplot"
    ]
  },
  {
    "objectID": "blocks/02-visualisation.html#density-plot",
    "href": "blocks/02-visualisation.html#density-plot",
    "title": "blockr",
    "section": "Density Plot",
    "text": "Density Plot\nDensity plots smooth histograms into continuous curves showing probability distributions. Use the “density” chart type to compare distributions across groups with overlapping curves.\nMap a continuous variable to x to create a density curve. The fill aesthetic creates separate curves for different groups, with alpha transparency allowing curves to overlap visibly. Density estimation automatically handles bandwidth selection, though you can adjust smoothing if needed.\nDensity plots work well for comparing distributions when you want smooth, continuous representations rather than binned histograms. They’re particularly effective with the alpha aesthetic set to 0.5-0.7, which makes overlapping distributions easy to distinguish. Use them to compare distribution shapes, identify modes, or assess whether groups follow similar patterns.",
    "crumbs": [
      "Blocks",
      "blockr.ggplot"
    ]
  },
  {
    "objectID": "blocks/02-visualisation.html#area-chart",
    "href": "blocks/02-visualisation.html#area-chart",
    "title": "blockr",
    "section": "Area Chart",
    "text": "Area Chart\nArea charts are filled line charts that emphasize cumulative magnitude over time. Use the “area” chart type to show how quantities accumulate or to emphasize the volume under curves.\nLike line charts, area charts map sequential data to x and continuous values to y. The fill aesthetic creates separate colored areas for different groups. Areas can be stacked (showing cumulative totals) or overlapped with alpha transparency (showing individual contributions). This makes them ideal for part-to-whole relationships over time.\nArea charts work best when the filled space has meaning, such as cumulative quantities, market shares, or resource allocation over time. The alpha aesthetic (0.6-0.8) is particularly important when comparing overlapping areas, as it allows all curves to remain visible while still emphasizing volume.",
    "crumbs": [
      "Blocks",
      "blockr.ggplot"
    ]
  },
  {
    "objectID": "blocks/02-visualisation.html#histogram",
    "href": "blocks/02-visualisation.html#histogram",
    "title": "blockr",
    "section": "Histogram",
    "text": "Histogram\nHistograms bin continuous data to show frequency distributions. Use the “histogram” chart type to understand the shape, center, and spread of a single variable.\nSelect a continuous variable for x. The block automatically creates bins and counts observations in each bin. The bins parameter controls the number of bins (default: 30) - fewer bins show general patterns, more bins reveal details. The fill aesthetic colors bars by groups, with position options controlling whether bars stack or dodge.\nHistograms are fundamental for exploratory data analysis: assessing whether data follows a normal distribution, identifying skewness or multimodality, detecting outliers, and understanding data range. Experiment with bin counts to find the right level of detail for your data’s density and range.",
    "crumbs": [
      "Blocks",
      "blockr.ggplot"
    ]
  },
  {
    "objectID": "blocks/02-visualisation.html#pie-chart",
    "href": "blocks/02-visualisation.html#pie-chart",
    "title": "blockr",
    "section": "Pie Chart",
    "text": "Pie Chart\nPie charts show proportions as slices of a circle. Use the “pie” chart type to display part-to-whole relationships for categorical data.\nMap a categorical variable to x and a numeric value to y. Each category becomes a slice, with slice size proportional to its value. The fill aesthetic colors slices by category, automatically creating a legend. Pie charts work best with a small number of categories (3-7) where relative sizes are easy to compare.\nWhile controversial among data visualization experts who prefer bar charts for precise comparisons, pie charts remain intuitive for showing simple proportions, especially when one category dominates or when emphasizing that parts constitute a whole. Keep categories limited and consider using a donut chart variant for a modern aesthetic.",
    "crumbs": [
      "Blocks",
      "blockr.ggplot"
    ]
  },
  {
    "objectID": "blocks/02-visualisation.html#donut-chart",
    "href": "blocks/02-visualisation.html#donut-chart",
    "title": "blockr",
    "section": "Donut Chart",
    "text": "Donut Chart\nDonut charts are pie charts with a center hole, offering a modern aesthetic and space for annotations. Use the “pie” chart type with the donut_hole parameter to create this variant.\nConfigure exactly like pie charts, but set donut_hole to a value between 0.3 and 0.7 to control the inner radius. The hole creates negative space that can reduce visual clutter and provides room for central labels or summary statistics. Donut charts are often considered more visually appealing than standard pie charts while conveying the same information.\nThe empty center draws attention and can be used strategically to display total values, titles, or key metrics. The ring shape also makes it slightly easier to compare arc lengths than full pie slices, as the curves are more linear. Use donut charts when aesthetics matter or when you want to emphasize the ring pattern over the center point.",
    "crumbs": [
      "Blocks",
      "blockr.ggplot"
    ]
  },
  {
    "objectID": "blocks/02-visualisation.html#facet-wrap-layout",
    "href": "blocks/02-visualisation.html#facet-wrap-layout",
    "title": "blockr",
    "section": "Facet: Wrap Layout",
    "text": "Facet: Wrap Layout\nThe facet block splits plots into multiple panels based on categorical variables. Use “wrap” mode for flexible grid layouts that flow naturally across rows.\nSelect a facet variable to create a separate panel for each unique value. The ncol parameter controls how many columns to use - facets fill columns left-to-right, then wrap to new rows. This is ideal when you have many facet levels or want automatic layout that adapts to available space.\nFacet wrap works well with 3-15 groups where you want to see each group’s pattern separately while maintaining visual comparison. It automatically handles scales: by default all facets share the same x and y scales for easy comparison, though you can set scales to “free” for independent axes. Use this for comparing patterns across time periods, regions, or categories.",
    "crumbs": [
      "Blocks",
      "blockr.ggplot"
    ]
  },
  {
    "objectID": "blocks/02-visualisation.html#facet-grid-layout",
    "href": "blocks/02-visualisation.html#facet-grid-layout",
    "title": "blockr",
    "section": "Facet: Grid Layout",
    "text": "Facet: Grid Layout\nFacet grid creates a matrix of panels based on two categorical variables - one for rows and one for columns. Use “grid” mode when you want to examine combinations of two factors.\nSelect variables for facet_rows and facet_cols to create a rows × columns layout. Each cell in the grid shows the intersection of one row category with one column category. This structured layout makes it easy to see how patterns vary across both dimensions simultaneously.\nFacet grid is powerful for experimental designs with multiple factors, comparing subgroups across time periods, or any situation where data is naturally organized by two categorical variables. The grid structure reveals interaction effects and makes systematic comparisons straightforward. Keep factor levels reasonable (typically 2-5 levels per dimension) to maintain readability.",
    "crumbs": [
      "Blocks",
      "blockr.ggplot"
    ]
  },
  {
    "objectID": "blocks/02-visualisation.html#theme-block",
    "href": "blocks/02-visualisation.html#theme-block",
    "title": "blockr",
    "section": "Theme Block",
    "text": "Theme Block\nThe theme block applies pre-defined styling to plots. Use themes to quickly change the overall appearance of visualizations without adjusting individual elements.\nSelect from over 20 built-in themes including classic ggplot2 themes (theme_minimal, theme_classic, theme_bw) and themes from extension packages like ggthemes. Each theme provides a coherent visual style with coordinated choices for backgrounds, grids, fonts, and colors.\nThemes control non-data elements: backgrounds, grid lines, axis styling, legend appearance, and text formatting. Apply a theme block after visualization blocks to style the entire plot consistently. Common choices include theme_minimal for clean presentations, theme_classic for publication-ready plots, and theme_dark for emphasis or presentations on dark backgrounds.",
    "crumbs": [
      "Blocks",
      "blockr.ggplot"
    ]
  },
  {
    "objectID": "blocks/02-visualisation.html#grid-block",
    "href": "blocks/02-visualisation.html#grid-block",
    "title": "blockr",
    "section": "Grid Block",
    "text": "Grid Block\nThe grid block composes multiple plots into a single figure using patchwork. Use this to create publication-ready figures combining related visualizations.\nSelect a layout style (horizontal, vertical, or grid) and specify the number of plots. The block automatically arranges connected plots according to your layout choice. Horizontal layouts place plots side-by-side for comparing across categories. Vertical layouts stack plots for showing different aspects of the same data. Grid layouts create matrices for comprehensive multi-panel figures.\nGrid composition is essential for complex figures that tell a complete story through multiple related views. Each input can be a complete visualization pipeline, allowing you to combine different chart types, subsets, or transformations. This is particularly powerful for academic papers, reports, or dashboards where you need to present multiple coordinated views.",
    "crumbs": [
      "Blocks",
      "blockr.ggplot"
    ]
  },
  {
    "objectID": "blocks/02-visualisation.html#building-visualization-pipelines",
    "href": "blocks/02-visualisation.html#building-visualization-pipelines",
    "title": "blockr",
    "section": "Building Visualization Pipelines",
    "text": "Building Visualization Pipelines\nBlocks work together in pipelines. Connect data transformation blocks (from blockr.dplyr) to visualization blocks to create end-to-end analysis workflows. The output from each block becomes the input to the next. Each block shows a preview at that stage, making it easy to understand how data flows through your pipeline.",
    "crumbs": [
      "Blocks",
      "blockr.ggplot"
    ]
  },
  {
    "objectID": "blocks/01-wrangling.html",
    "href": "blocks/01-wrangling.html",
    "title": "tidyr Blocks",
    "section": "",
    "text": "blockr.dplyr provides interactive blocks for data wrangling. Each block offers a user interface for a specific data transformation task. Blocks can be connected together to create data transformation pipelines.\nThis package includes blocks for common dplyr operations (select, filter, arrange, mutate, summarize, join, bind) and tidyr operations (pivot, separate, unite).",
    "crumbs": [
      "Blocks",
      "blockr.dplyr"
    ]
  },
  {
    "objectID": "blocks/01-wrangling.html#blockr.dplyr",
    "href": "blocks/01-wrangling.html#blockr.dplyr",
    "title": "tidyr Blocks",
    "section": "",
    "text": "blockr.dplyr provides interactive blocks for data wrangling. Each block offers a user interface for a specific data transformation task. Blocks can be connected together to create data transformation pipelines.\nThis package includes blocks for common dplyr operations (select, filter, arrange, mutate, summarize, join, bind) and tidyr operations (pivot, separate, unite).",
    "crumbs": [
      "Blocks",
      "blockr.dplyr"
    ]
  },
  {
    "objectID": "blocks/01-wrangling.html#select-block",
    "href": "blocks/01-wrangling.html#select-block",
    "title": "tidyr Blocks",
    "section": "Select Block",
    "text": "Select Block\nThe select block chooses which columns to keep in your dataset.\nUse the column selector to pick the columns you want. You can select multiple columns and reorder them by dragging. The order of selection determines the column order in the output.\nThe block includes a “distinct” option. When enabled, duplicate rows are removed from the result, keeping only unique combinations of the selected columns.",
    "crumbs": [
      "Blocks",
      "blockr.dplyr"
    ]
  },
  {
    "objectID": "blocks/01-wrangling.html#filter-block",
    "href": "blocks/01-wrangling.html#filter-block",
    "title": "tidyr Blocks",
    "section": "Filter Block",
    "text": "Filter Block\nThe filter block filters rows by selecting values from dropdown lists. This provides a point-and-click interface that does not require writing expressions. Use this block when you want to visually select which values to include or exclude, especially for categorical columns.\nFor each filter condition, select a column from the dropdown. The interface displays all unique values in that column. Select one or more values to filter by. Choose between “include” mode (keep only rows with selected values) or “exclude” mode (remove rows with selected values).\nAdd multiple conditions using the “+ Add Condition” button. Each condition can be combined with the previous one using AND (all conditions must be true) or OR (at least one condition must be true) logic. The “Preserve selection order” option maintains the order of selected values in the output.\nFor more elaborate filter conditions using comparisons or calculations, use the filter expression block instead.",
    "crumbs": [
      "Blocks",
      "blockr.dplyr"
    ]
  },
  {
    "objectID": "blocks/01-wrangling.html#filter-expression-block",
    "href": "blocks/01-wrangling.html#filter-expression-block",
    "title": "tidyr Blocks",
    "section": "Filter Expression Block",
    "text": "Filter Expression Block\nThe filter expression block keeps only rows that meet specific conditions using R expressions. Use this block for more elaborate filtering that cannot be achieved with simple value selection, such as numeric comparisons, calculations, or complex logical conditions.\nSupported operators include &gt;, &lt;, ==, !=, &gt;=, &lt;= for comparisons, and %in% for checking membership in a set of values. Combine multiple conditions using & (AND) to require all conditions to be true, or | (OR) to require at least one condition to be true. The expression editor provides syntax highlighting and validates your expressions. Examples: mpg &gt; 20, cyl == 4 | cyl == 6, hp &gt; 100 & wt &lt; 3.",
    "crumbs": [
      "Blocks",
      "blockr.dplyr"
    ]
  },
  {
    "objectID": "blocks/01-wrangling.html#arrange-block",
    "href": "blocks/01-wrangling.html#arrange-block",
    "title": "tidyr Blocks",
    "section": "Arrange Block",
    "text": "Arrange Block\nThe arrange block sorts rows by column values. Select one or more columns to sort by, with each column having its own ascending or descending control.\nWhen sorting by multiple columns, the order matters. The first column is the primary sort key. Rows with the same value in the first column are then sorted by the second column, and so on. Use the drag handles to reorder the sort columns.\nAdd columns using the “+” button and remove them using the “×” button. Toggle between ascending and descending order for each column independently.",
    "crumbs": [
      "Blocks",
      "blockr.dplyr"
    ]
  },
  {
    "objectID": "blocks/01-wrangling.html#slice-block",
    "href": "blocks/01-wrangling.html#slice-block",
    "title": "tidyr Blocks",
    "section": "Slice Block",
    "text": "Slice Block\nThe slice block selects specific rows based on different criteria. Choose from six slice types: head (first rows), tail (last rows), min (rows with smallest values), max (rows with largest values), sample (random selection), or custom (specific positions).\nFor head and tail types, specify the number of rows using n (count) or prop (proportion between 0 and 1). For min and max types, select an order_by column and enable with_ties if you want to include all rows with tied values. For sample type, optionally select a weight_by column for weighted sampling and enable replace for sampling with replacement.\nThe custom type accepts a rows expression like “1:5” or “c(1, 3, 5, 10)”. All slice types support grouping via the by parameter, which performs the slice operation within each group separately.",
    "crumbs": [
      "Blocks",
      "blockr.dplyr"
    ]
  },
  {
    "objectID": "blocks/01-wrangling.html#mutate-expression-block",
    "href": "blocks/01-wrangling.html#mutate-expression-block",
    "title": "tidyr Blocks",
    "section": "Mutate Expression Block",
    "text": "Mutate Expression Block\nThe mutate expression block creates new columns or modifies existing ones using R expressions. Add multiple expressions, each creating or updating a column. Each expression consists of a column name and an R expression that calculates its value.\nUse mathematical operators (+, -, *, /, ^) and functions (sqrt(), log(), round(), etc.) in your expressions. Reference existing columns by name. You can also use conditional logic with ifelse() or dplyr::case_when().\nExpression order matters: later expressions can reference columns created by earlier expressions in the same mutate block. The by parameter allows grouping, making column references operate within each group. Add expressions with the “+ Add Expression” button and remove them with the “×” button.",
    "crumbs": [
      "Blocks",
      "blockr.dplyr"
    ]
  },
  {
    "objectID": "blocks/01-wrangling.html#rename-block",
    "href": "blocks/01-wrangling.html#rename-block",
    "title": "tidyr Blocks",
    "section": "Rename Block",
    "text": "Rename Block\nThe rename block changes column names. Each rename operation maps a new name to an existing column. The interface shows the mapping as “new_name ← old_name” with a visual arrow indicator.\nSelect the existing column from a dropdown to ensure valid column names. Type the new name in the text field. Add multiple renames using the “+” button to rename several columns at once. Remove a rename operation with the “×” button.\nThe block validates that you don’t rename the same column twice and ensures column names don’t conflict with existing names.",
    "crumbs": [
      "Blocks",
      "blockr.dplyr"
    ]
  },
  {
    "objectID": "blocks/01-wrangling.html#summarize-block",
    "href": "blocks/01-wrangling.html#summarize-block",
    "title": "tidyr Blocks",
    "section": "Summarize Block",
    "text": "Summarize Block\nThe summarize block calculates summary statistics using a point-and-click interface. Each summary consists of three parts: a name for the new column, an aggregation function selected from a dropdown, and the column to aggregate.\nAvailable aggregation functions include mean, sum, minimum, maximum, count, count distinct, median, standard deviation, and more. Select the function from the dropdown and the column to apply it to.\nUse the “Columns to group by” selector to group data before summarizing. When grouping is enabled, statistics are calculated separately for each group. Add multiple summaries using the “+ Add Summary” button.\nFor more complex aggregations using custom R expressions, use the summarize expression block instead.",
    "crumbs": [
      "Blocks",
      "blockr.dplyr"
    ]
  },
  {
    "objectID": "blocks/01-wrangling.html#summarize-expression-block",
    "href": "blocks/01-wrangling.html#summarize-expression-block",
    "title": "tidyr Blocks",
    "section": "Summarize Expression Block",
    "text": "Summarize Expression Block\nThe summarize expression block calculates summary statistics using R expressions. Use this block for more elaborate aggregations that require custom expressions, such as weighted means, ratios, or functions with specific parameters.\nEnter expressions like mean(mpg), sum(hp), dplyr::n(), or more complex calculations like mean(mpg, na.rm = TRUE) or sum(hp) / dplyr::n(). The expression editor provides syntax highlighting and autocomplete (Ctrl+Space).\nUse the “Columns to group by” selector to group data before summarizing. The “Show advanced options” section provides additional settings like the unpack option for handling functions that return data frames.",
    "crumbs": [
      "Blocks",
      "blockr.dplyr"
    ]
  },
  {
    "objectID": "blocks/01-wrangling.html#join-block",
    "href": "blocks/01-wrangling.html#join-block",
    "title": "tidyr Blocks",
    "section": "Join Block",
    "text": "Join Block\nThe join block combines two datasets based on matching values in specified columns. Select from six join types that determine which rows are kept in the result.\nJoin types: left_join keeps all rows from the left dataset and matching rows from the right; right_join keeps all rows from the right dataset and matching rows from the left; inner_join keeps only rows that match in both datasets; full_join keeps all rows from both datasets; semi_join filters the left dataset to rows that have a match in the right; anti_join filters the left dataset to rows that do not have a match in the right.\nThe “Custom Column Mappings” interface supports both same-name joins (when columns have identical names) and different-name joins (when the matching columns have different names in each dataset). Add multiple join keys to match on multiple columns simultaneously. Enable “Use natural join” to automatically join on all common columns.",
    "crumbs": [
      "Blocks",
      "blockr.dplyr"
    ]
  },
  {
    "objectID": "blocks/01-wrangling.html#bind-rows-block",
    "href": "blocks/01-wrangling.html#bind-rows-block",
    "title": "tidyr Blocks",
    "section": "Bind Rows Block",
    "text": "Bind Rows Block\nThe bind rows block stacks datasets vertically by matching column names. Rows from each input dataset are combined into a single output dataset.\nColumns are matched by name. If datasets have different columns, the result includes all columns from all datasets. Missing columns are filled with NA values. The order of columns in the output follows the order they appear across all input datasets.\nThe “Show advanced options” section provides the id_name option which adds an identifier column that tracks which source dataset each row came from. This is useful when combining data from multiple sources and you need to maintain provenance.",
    "crumbs": [
      "Blocks",
      "blockr.dplyr"
    ]
  },
  {
    "objectID": "blocks/01-wrangling.html#bind-columns-block",
    "href": "blocks/01-wrangling.html#bind-columns-block",
    "title": "tidyr Blocks",
    "section": "Bind Columns Block",
    "text": "Bind Columns Block\nThe bind columns block combines datasets side-by-side horizontally. Columns from each input dataset are placed next to each other in the output.\nAll input datasets must have exactly the same number of rows. The rows are combined by position: the first row from each dataset forms the first row of the output, the second rows form the second row of the output, and so on.\nIf datasets have columns with the same name, they are automatically renamed with numeric suffixes (e.g., “Sepal.Length…1”, “Sepal.Length…6”) to avoid conflicts.",
    "crumbs": [
      "Blocks",
      "blockr.dplyr"
    ]
  },
  {
    "objectID": "blocks/01-wrangling.html#pivot-longer-block",
    "href": "blocks/01-wrangling.html#pivot-longer-block",
    "title": "tidyr Blocks",
    "section": "Pivot Longer Block",
    "text": "Pivot Longer Block\nThe pivot longer block reshapes data from wide to long format using tidyr::pivot_longer(). Use this when column names represent values of a variable rather than variables themselves.\nSelect which columns to pivot. These columns are transformed into two new columns: one containing the original column names (names_to parameter, default “name”) and another containing the values (values_to parameter, default “value”). Unselected columns remain as identifiers.\nThe “Show advanced options” section provides names_prefix (removes common prefixes from column names) and values_drop_na (removes rows where the value is NA). This is useful for reshaping time series data, survey responses, or preparing data for visualization.",
    "crumbs": [
      "Blocks",
      "blockr.dplyr"
    ]
  },
  {
    "objectID": "blocks/01-wrangling.html#pivot-wider-block",
    "href": "blocks/01-wrangling.html#pivot-wider-block",
    "title": "tidyr Blocks",
    "section": "Pivot Wider Block",
    "text": "Pivot Wider Block\nThe pivot wider block reshapes data from long to wide format using tidyr::pivot_wider(). This is the inverse of pivot longer, creating a summary table where row-column combinations become cells.\nSelect which column contains values for new column names (names_from) and which column contains cell values (values_from). The id_cols parameter specifies which columns identify each row. If empty, all columns not in names_from or values_from are used as identifiers.\nThe “Show advanced options” section provides names_prefix (adds a prefix to new column names) and values_fill (provides a value for missing combinations). This is useful for creating crosstabs, pivot tables, or comparing values across categories.",
    "crumbs": [
      "Blocks",
      "blockr.dplyr"
    ]
  },
  {
    "objectID": "blocks/01-wrangling.html#separate-block",
    "href": "blocks/01-wrangling.html#separate-block",
    "title": "tidyr Blocks",
    "section": "Separate Block",
    "text": "Separate Block\nThe separate block splits a single column into multiple columns using tidyr::separate(). Use this when a column contains combined values that should be in separate columns.\nSelect the column to separate and specify the names for the new columns (comma-separated). Enter the separator character or regular expression that divides the values.\nThe “Show advanced options” section provides remove (whether to remove the input column), convert (whether to convert new columns to appropriate types), and extra/fill options for handling rows with too many or too few pieces.",
    "crumbs": [
      "Blocks",
      "blockr.dplyr"
    ]
  },
  {
    "objectID": "blocks/01-wrangling.html#unite-block",
    "href": "blocks/01-wrangling.html#unite-block",
    "title": "tidyr Blocks",
    "section": "Unite Block",
    "text": "Unite Block\nThe unite block combines multiple columns into a single column using tidyr::unite(). This is the inverse of separate, joining values with a separator.\nSelect the columns to unite and specify the name for the new combined column. Enter the separator character to place between values (default is “_“).\nThe “Show advanced options” section provides the remove option (whether to remove the input columns after uniting) and na.rm (whether to remove NA values before uniting).",
    "crumbs": [
      "Blocks",
      "blockr.dplyr"
    ]
  },
  {
    "objectID": "blocks/01-wrangling.html#building-data-pipelines",
    "href": "blocks/01-wrangling.html#building-data-pipelines",
    "title": "tidyr Blocks",
    "section": "Building Data Pipelines",
    "text": "Building Data Pipelines\nBlocks work together in pipelines. The output from one block becomes the input to the next. Each block shows a preview of the data at that stage.",
    "crumbs": [
      "Blocks",
      "blockr.dplyr"
    ]
  },
  {
    "objectID": "blocks/03-io.html",
    "href": "blocks/03-io.html",
    "title": "blockr",
    "section": "",
    "text": "blockr.io provides unified file I/O blocks for reading and writing data in blockr pipelines. The read block handles loading data from multiple sources and formats with a smart, adaptive interface. The write block enables exporting data to various file formats, with support for browser downloads or filesystem output. Together, these blocks make it easy to build complete data workflows from input to output.",
    "crumbs": [
      "Blocks",
      "blockr.io"
    ]
  },
  {
    "objectID": "blocks/03-io.html#blockr.io",
    "href": "blocks/03-io.html#blockr.io",
    "title": "blockr",
    "section": "",
    "text": "blockr.io provides unified file I/O blocks for reading and writing data in blockr pipelines. The read block handles loading data from multiple sources and formats with a smart, adaptive interface. The write block enables exporting data to various file formats, with support for browser downloads or filesystem output. Together, these blocks make it easy to build complete data workflows from input to output.",
    "crumbs": [
      "Blocks",
      "blockr.io"
    ]
  },
  {
    "objectID": "blocks/03-io.html#read-block",
    "href": "blocks/03-io.html#read-block",
    "title": "blockr",
    "section": "Read Block",
    "text": "Read Block\nThe read block is a versatile data loading block that automatically adapts its interface based on the file type you’re working with. It combines three different file source modes (upload, browse, URL) with format-specific options for CSV, Excel, and other file types.\n\nThree Ways to Load Data\nUpload Mode: Drag and drop files or click to browse from your computer. Uploaded files are stored persistently, so they remain available across sessions. This is perfect for interactive data analysis where you want to upload a dataset once and keep working with it.\nBrowse Mode: Navigate your file system using an interactive file browser. Select files from configured folder paths. The block reads directly from the original file location without copying.\nURL Mode: Download data directly from a web URL. Simply paste a URL pointing to a CSV, Excel, or other supported file format. The data is downloaded fresh when the session starts.\n\n\nSmart Interface\nThe block detects your file type and shows relevant options:\nCSV/TSV files display options for delimiter (comma, semicolon, tab), quote character, encoding, row skipping, and whether the first row contains column names. This gives you full control over how delimited text files are parsed.\nExcel files show dropdown menus for sheet selection, cell range specification (like “A1:C100”), row skipping, and column name options. You can target specific sheets and ranges within your Excel workbooks.\nOther formats (Parquet, Feather, SPSS, Stata, SAS, JSON, XML, etc.) are handled automatically with minimal configuration. The block uses the appropriate reader based on file extension.\n\n\nWorking with Multiple Files\nWhen you select multiple files, the block provides combination strategies:\n\nAuto: Automatically stacks files vertically if they have the same columns, otherwise uses just the first file\nRow bind: Stack files vertically (requires files to have the same columns)\nColumn bind: Place files side-by-side (requires files to have the same number of rows)\nFirst only: Use only the first file, ignore the others\n\nThis makes it easy to load and combine related datasets in one step.",
    "crumbs": [
      "Blocks",
      "blockr.io"
    ]
  },
  {
    "objectID": "blocks/03-io.html#supported-file-formats",
    "href": "blocks/03-io.html#supported-file-formats",
    "title": "blockr",
    "section": "Supported File Formats",
    "text": "Supported File Formats\nThe block supports a wide range of file formats:\nText formats: CSV, TSV, TXT, fixed-width files\nSpreadsheets: Excel (.xlsx, .xls), OpenDocument Spreadsheet (.ods)\nStatistical software: SPSS (.sav), Stata (.dta), SAS (.sas7bdat, .xpt)\nColumnar formats: Parquet, Feather, Arrow IPC\nWeb formats: JSON, XML, HTML\nR formats: RDS, RData\nDatabase formats: DBF, SQLite",
    "crumbs": [
      "Blocks",
      "blockr.io"
    ]
  },
  {
    "objectID": "blocks/03-io.html#write-block",
    "href": "blocks/03-io.html#write-block",
    "title": "blockr",
    "section": "Write Block",
    "text": "Write Block\nThe write block is a versatile data export block that accepts one or more dataframe inputs and outputs files in various formats. It provides flexible options for file naming, output location, and format-specific parameters.\n\nTwo Output Modes\nDownload Mode: The block triggers a browser download, saving the file to your downloads folder. This is the recommended mode for beginners and for exporting analysis results. Files are generated on-demand when you click the download button.\nBrowse Mode: Write files directly to the server filesystem. Use the directory browser to select where files should be saved. Files are written immediately when upstream data changes, making this ideal for automated pipelines.\n\n\nFilename Behavior\nFixed filename: Specify a filename (without extension) to create reproducible output. The block always writes to the same path, overwriting the file when upstream data changes. Perfect for automated workflows where you want consistent file paths.\nAuto-timestamped: Leave the filename empty to generate unique timestamped files (e.g., data_20250127_143022.csv). This preserves history and prevents accidental overwrites, making it the safe default behavior.\n\n\nMultiple Input Handling\nThe write block accepts multiple dataframe inputs, similar to how you might combine datasets. The output format depends on the file type:\nExcel format: Multiple inputs become sheets in a single Excel workbook. Sheet names are derived from input names (e.g., “sales_data”, “inventory”).\nCSV/Arrow formats: Multiple inputs are bundled into a ZIP archive. Each dataframe is saved as a separate file using the input names.\nSingle input: Outputs a single file in the specified format.\n\n\nSupported Output Formats\n\nCSV: Comma-separated values with configurable delimiter, quotes, and NA handling\nExcel: .xlsx workbooks with support for multiple sheets\nParquet: Efficient columnar storage format\nFeather: Fast binary format for data frames\n\nFormat-specific options (like CSV delimiter or quote character) can be configured through the args parameter.",
    "crumbs": [
      "Blocks",
      "blockr.io"
    ]
  },
  {
    "objectID": "blocks/03-io.html#building-complete-pipelines",
    "href": "blocks/03-io.html#building-complete-pipelines",
    "title": "blockr",
    "section": "Building Complete Pipelines",
    "text": "Building Complete Pipelines\nThe read and write blocks work seamlessly with other blockr blocks to create end-to-end data workflows. Load data with the read block, transform it with processing blocks, visualize results, and export with the write block - all without writing code.\nFor example, you could build a pipeline that: 1. Loads sales data from a CSV file (read block) 2. Filters to show only high-revenue transactions (filter block) 3. Aggregates by product category (summarize block) 4. Creates a visualization (plot block) 5. Exports the processed data to Excel (write block)\nJust connect the blocks together to create powerful, reproducible data workflows!",
    "crumbs": [
      "Blocks",
      "blockr.io"
    ]
  },
  {
    "objectID": "fundamentals/01-reactivity.html",
    "href": "fundamentals/01-reactivity.html",
    "title": "Reactivity",
    "section": "",
    "text": "blockr uses a concept called reactivity to ensure that any changes you make to a block in your workflow are automatically reflected in all downstream blocks. This means that when you update one part of your workflow, you don’t need to manually trigger updates elsewhere, everything downstream adjusts automatically. It’s the same idea that powers the interactivity you’re used to seeing in spreadsheets: if cell A1 contains a price and cell B1 calculates tax with =A1 * 0.2, changing A1 instantly updates B1. blockr works the same way, but for entire data transformation steps instead of individual cells.\n\n\n\n\n\n\nNote\n\n\n\nblockr did not invent reactivity! blockr is built on the Shiny framework in R, which itself borrowed the ideas of reactivity from Meteor\n\n\n\n\n\nIf you have already completed the Build a dashboard tutorial, you have already seen reactivity in action. In that tutorial you learnt how to build a simple dashboard which uses a filter to update a plot on penguins:\n\nLet’s zoom into the workflow to better understand what is going on. Here, we can see that as one block updates, all downstream blocks update:\n\nIn this example, this results in only a single block updating.\nA downstream block is any block that depends on (directly or indirectly) the output of a given block. In other words, it comes after it in the workflow. If data flows from A → B → C, then B and C are both downstream of A. This means that for complicated workflows, a change higher up the workflow can result in many blocks being updated:\n\nNote that upstream blocks never get updated. In our simple example, this means that our data block does not get updated, because it is upstream of our filter block:\n\n\n\n\nSometimes updating a block can causes errors downstream.\nFor example, again using our simple penguins dashboard, if we update the dataset block to use a dataset other than penguins, it will causes errors downstream:\n\nThis happens because the downstream filter and plot blocks user variables from the penguins dataset. When this dataset changes, these variables are no longer available and so the downstream blocks error to let us know they are trying to use variables that no longer exist. In this instance to fix these errors, we just need to update the variables used in the downstream blocks to those found in the new dataset.",
    "crumbs": [
      "Fundamentals",
      "Reactivity"
    ]
  },
  {
    "objectID": "fundamentals/01-reactivity.html#overview",
    "href": "fundamentals/01-reactivity.html#overview",
    "title": "Reactivity",
    "section": "",
    "text": "blockr uses a concept called reactivity to ensure that any changes you make to a block in your workflow are automatically reflected in all downstream blocks. This means that when you update one part of your workflow, you don’t need to manually trigger updates elsewhere, everything downstream adjusts automatically. It’s the same idea that powers the interactivity you’re used to seeing in spreadsheets: if cell A1 contains a price and cell B1 calculates tax with =A1 * 0.2, changing A1 instantly updates B1. blockr works the same way, but for entire data transformation steps instead of individual cells.\n\n\n\n\n\n\nNote\n\n\n\nblockr did not invent reactivity! blockr is built on the Shiny framework in R, which itself borrowed the ideas of reactivity from Meteor",
    "crumbs": [
      "Fundamentals",
      "Reactivity"
    ]
  },
  {
    "objectID": "fundamentals/01-reactivity.html#example",
    "href": "fundamentals/01-reactivity.html#example",
    "title": "Reactivity",
    "section": "",
    "text": "If you have already completed the Build a dashboard tutorial, you have already seen reactivity in action. In that tutorial you learnt how to build a simple dashboard which uses a filter to update a plot on penguins:\n\nLet’s zoom into the workflow to better understand what is going on. Here, we can see that as one block updates, all downstream blocks update:\n\nIn this example, this results in only a single block updating.\nA downstream block is any block that depends on (directly or indirectly) the output of a given block. In other words, it comes after it in the workflow. If data flows from A → B → C, then B and C are both downstream of A. This means that for complicated workflows, a change higher up the workflow can result in many blocks being updated:\n\nNote that upstream blocks never get updated. In our simple example, this means that our data block does not get updated, because it is upstream of our filter block:",
    "crumbs": [
      "Fundamentals",
      "Reactivity"
    ]
  },
  {
    "objectID": "fundamentals/01-reactivity.html#errors",
    "href": "fundamentals/01-reactivity.html#errors",
    "title": "Reactivity",
    "section": "",
    "text": "Sometimes updating a block can causes errors downstream.\nFor example, again using our simple penguins dashboard, if we update the dataset block to use a dataset other than penguins, it will causes errors downstream:\n\nThis happens because the downstream filter and plot blocks user variables from the penguins dataset. When this dataset changes, these variables are no longer available and so the downstream blocks error to let us know they are trying to use variables that no longer exist. In this instance to fix these errors, we just need to update the variables used in the downstream blocks to those found in the new dataset.",
    "crumbs": [
      "Fundamentals",
      "Reactivity"
    ]
  },
  {
    "objectID": "tutorials/01-build-your-first-app.html",
    "href": "tutorials/01-build-your-first-app.html",
    "title": "Build your first app",
    "section": "",
    "text": "This tutorial will get you started with blockr in just a few minutes. By the end, you will have built your first data pipeline.\n\n\n\n\nThe simplest way to try blockr is for free in our live playground at blockr.cloud. Note, you will not be able to save and restore sessions this way.\n\n\n\nRun the following commands to install blockr locally and then spin up an empty app:\ninstall.packages(\"blockr\") # Download blockr. This only needs to be run once.\nblockr::run_app() # Start an empty app. Run this each time you want to boot up blockr.\n\n\n\n\n\n\nNote\n\n\n\nInstalling blockr locally assumes you already have R installed on your system and are comfortable running basic R commands.\n\n\n\n\n\n\n\n\nEach empty blockr app starts with a blank canvas:\n\nTo build a workflow, simply add some blocks to your canvas, connect them, and then watch blockr automatically run the workflows!\nLet’s start by adding some data. Right-click the canvas then click “Add block”:\n\nThis opens the right sidebar with a block selection menu. Here, blocks are sorted into categories like Inputs, Outputs, and Plots, so you can easily browse and discover them. You can also use the search bar to find blocks.\nFor now, let’s click “dataset block” to load an example data block, preconfigured with a bunch of different datasets.\n\nOnce the block is added to the canvas, the contents of the block will be loaded to the right-hand panel. Let’s change the dataset to penguins by clicking and searching in the drop-down menu:\n\n\n\n\nNext, let’s filter our penguins data to only return the species “Adelie” and “Chinstrap”.\nTo connect a filter block:\n\nHover the mouse over the dataset block\nClick the “+” button at the bottom of the block, called a port, to bring up the block menu sidebar once more:\nSearch for “filter” and click “Filter Rows”\n\n\nThis will add a new connected filter block to the canvas. From here, we can filter the data to just keep the “Adelie” and “Chinstrap” species of penguins by seleting their values from the “Values” drop-down box:\n\n\n\n\nFinally, let’s finish our first pipeline by visualising some data. To do that, let’s add a visualisation block, but use a different method to do that.\nFirst, right-click anywhere in the canvas and click “Add block” like we did in the first step of this tutorial:\n\nThen search for “plot” and click “ggplot” to add a plot block to our canvas:\n\nThis will add an unconnected plot block to our canvas. We know that the block is unconnected because there are no connecting arrows from our other blocks to our plot block:\n\nTo connect the plot block, hover the mouse over the filter block to view the available ports. Then, click and drag from the port on the bottom of the filter block to the port on the top of the plot block.\n\n\n\n\n\n\nNote\n\n\n\nNotice how the dotted line around the port on the plot block becomes solid to indicate that a connection can be made.\n\n\n\nTo finish let’s populate some of the inputs in the plot block to create a scatter plot of penguin bill length versus bill depth across the different species:\n\n\n\n\n\nAnd that’s it! You’ve learned how to add blocks to the canvas, search for blocks, and connect them using ports. You now have the skills to import, transform, and visualize data in blockr.",
    "crumbs": [
      "Tutorials",
      "Build your first app"
    ]
  },
  {
    "objectID": "tutorials/01-build-your-first-app.html#start-blockr",
    "href": "tutorials/01-build-your-first-app.html#start-blockr",
    "title": "Build your first app",
    "section": "",
    "text": "The simplest way to try blockr is for free in our live playground at blockr.cloud. Note, you will not be able to save and restore sessions this way.\n\n\n\nRun the following commands to install blockr locally and then spin up an empty app:\ninstall.packages(\"blockr\") # Download blockr. This only needs to be run once.\nblockr::run_app() # Start an empty app. Run this each time you want to boot up blockr.\n\n\n\n\n\n\nNote\n\n\n\nInstalling blockr locally assumes you already have R installed on your system and are comfortable running basic R commands.",
    "crumbs": [
      "Tutorials",
      "Build your first app"
    ]
  },
  {
    "objectID": "tutorials/01-build-your-first-app.html#first-steps",
    "href": "tutorials/01-build-your-first-app.html#first-steps",
    "title": "Build your first app",
    "section": "",
    "text": "Each empty blockr app starts with a blank canvas:\n\nTo build a workflow, simply add some blocks to your canvas, connect them, and then watch blockr automatically run the workflows!\nLet’s start by adding some data. Right-click the canvas then click “Add block”:\n\nThis opens the right sidebar with a block selection menu. Here, blocks are sorted into categories like Inputs, Outputs, and Plots, so you can easily browse and discover them. You can also use the search bar to find blocks.\nFor now, let’s click “dataset block” to load an example data block, preconfigured with a bunch of different datasets.\n\nOnce the block is added to the canvas, the contents of the block will be loaded to the right-hand panel. Let’s change the dataset to penguins by clicking and searching in the drop-down menu:\n\n\n\n\nNext, let’s filter our penguins data to only return the species “Adelie” and “Chinstrap”.\nTo connect a filter block:\n\nHover the mouse over the dataset block\nClick the “+” button at the bottom of the block, called a port, to bring up the block menu sidebar once more:\nSearch for “filter” and click “Filter Rows”\n\n\nThis will add a new connected filter block to the canvas. From here, we can filter the data to just keep the “Adelie” and “Chinstrap” species of penguins by seleting their values from the “Values” drop-down box:\n\n\n\n\nFinally, let’s finish our first pipeline by visualising some data. To do that, let’s add a visualisation block, but use a different method to do that.\nFirst, right-click anywhere in the canvas and click “Add block” like we did in the first step of this tutorial:\n\nThen search for “plot” and click “ggplot” to add a plot block to our canvas:\n\nThis will add an unconnected plot block to our canvas. We know that the block is unconnected because there are no connecting arrows from our other blocks to our plot block:\n\nTo connect the plot block, hover the mouse over the filter block to view the available ports. Then, click and drag from the port on the bottom of the filter block to the port on the top of the plot block.\n\n\n\n\n\n\nNote\n\n\n\nNotice how the dotted line around the port on the plot block becomes solid to indicate that a connection can be made.\n\n\n\nTo finish let’s populate some of the inputs in the plot block to create a scatter plot of penguin bill length versus bill depth across the different species:",
    "crumbs": [
      "Tutorials",
      "Build your first app"
    ]
  },
  {
    "objectID": "tutorials/01-build-your-first-app.html#summary",
    "href": "tutorials/01-build-your-first-app.html#summary",
    "title": "Build your first app",
    "section": "",
    "text": "And that’s it! You’ve learned how to add blocks to the canvas, search for blocks, and connect them using ports. You now have the skills to import, transform, and visualize data in blockr.",
    "crumbs": [
      "Tutorials",
      "Build your first app"
    ]
  },
  {
    "objectID": "tutorials/03-youtube-series.html",
    "href": "tutorials/03-youtube-series.html",
    "title": "YouTube tutorials",
    "section": "",
    "text": "YouTube tutorials\nIn addition to these written docs, video tutorials are also available here.",
    "crumbs": [
      "Tutorials",
      "YouTube tutorials"
    ]
  },
  {
    "objectID": "howto/02-save-and-restore.html",
    "href": "howto/02-save-and-restore.html",
    "title": "Save and restore workflows",
    "section": "",
    "text": "Learn how to save and restore workflows in blockr. Let’s start with a simple workflow where we visualise some penguins data using three blocks:\n\n\n\n\nYou can rename your workflow by editing the top-left corner text box. Alternatively, you can stick with the randomly generated default name.\n\n\n\nHit the save button to save the current state of your workflow.\n\n\n\nNext, let’s make some changes to your workflow. Here, let’s add a second plot:\n\n\n\nThen, hit save again to save the new state of your workflow.\n\n\n\nNow, to restore a previous version of our workflow the first thing we need to do is open the workflow manager. To do this, press the workflow button in the top-left corner:\n\n\n\nFrom here, press the history tab to open a list of all saved versions of our penguins dashboard. Each save point is an item in the list, with a timestamp of when it was saved.\n\n\n\nLet’s press the first time stamp (here labelled 1 min ago) to restore out previous version of the workflow:\n\n\n\nAlternatively, press the “View all versions” button to bring up the version history manager which provides you even more control of version restoration and deletion:\n\n\n\nFinally, let’s change our workflow completely by using the C02 dataset instead of penguins and save this new workflow:\n\n\n\nNow we can save and restore different workflows using the workflow tab in the workflow manager. Like before, these are presented in a timestamped list, and the “View all workflows” button can be pressed to bring up finer-grained controls:",
    "crumbs": [
      "How-To",
      "Save and restore workflows"
    ]
  },
  {
    "objectID": "howto/02-save-and-restore.html#steps",
    "href": "howto/02-save-and-restore.html#steps",
    "title": "Save and restore workflows",
    "section": "",
    "text": "You can rename your workflow by editing the top-left corner text box. Alternatively, you can stick with the randomly generated default name.\n\n\n\nHit the save button to save the current state of your workflow.\n\n\n\nNext, let’s make some changes to your workflow. Here, let’s add a second plot:\n\n\n\nThen, hit save again to save the new state of your workflow.\n\n\n\nNow, to restore a previous version of our workflow the first thing we need to do is open the workflow manager. To do this, press the workflow button in the top-left corner:\n\n\n\nFrom here, press the history tab to open a list of all saved versions of our penguins dashboard. Each save point is an item in the list, with a timestamp of when it was saved.\n\n\n\nLet’s press the first time stamp (here labelled 1 min ago) to restore out previous version of the workflow:\n\n\n\nAlternatively, press the “View all versions” button to bring up the version history manager which provides you even more control of version restoration and deletion:\n\n\n\nFinally, let’s change our workflow completely by using the C02 dataset instead of penguins and save this new workflow:\n\n\n\nNow we can save and restore different workflows using the workflow tab in the workflow manager. Like before, these are presented in a timestamped list, and the “View all workflows” button can be pressed to bring up finer-grained controls:",
    "crumbs": [
      "How-To",
      "Save and restore workflows"
    ]
  }
]